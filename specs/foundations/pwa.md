# Progressive Web App (PWA)

## Context

Coffee Tracker (Brew Lab) needs to be installable on mobile devices — primarily Android — so the user can launch it from the home screen without opening a browser. The app already has HTTPS via Caddy, responsive design, and SPA routing, so the PWA foundation is in place. The goal is **installability and standalone display**, not offline-first data access.

## Scope

**In scope:**
- Web App Manifest for installability
- Service worker for app shell precaching
- Google Fonts caching
- Standalone display mode (no browser chrome)
- Home screen icon and splash screen

**Explicitly excluded:**
- Offline data access (IndexedDB)
- Background sync for mutations
- Push notifications
- Custom install prompt UI

## Manifest

The manifest is auto-generated by `vite-plugin-pwa` from the Vite config. Key values:

| Field | Value | Rationale |
|-------|-------|-----------|
| `name` | `Brew Lab` | Full app name for install prompts and splash screens |
| `short_name` | `Brew Lab` | Home screen label (≤12 chars) |
| `description` | `Track and perfect your coffee brewing` | Install prompt subtitle |
| `start_url` | `/` | Entry point when launched from home screen |
| `display` | `standalone` | No browser chrome — feels native |
| `theme_color` | `#0d9488` | Teal-600 — matches primary color; used for Android status bar |
| `background_color` | `#fafafa` | Zinc-50 — light mode page background; splash screen color |

### Display Mode

`standalone` removes the browser address bar and navigation. The app fills the screen like a native app. Back navigation is handled by the app's own router.

## Icons

Six icon files in `frontend/public/`:

| File | Size | Purpose |
|------|------|---------|
| `pwa-64x64.png` | 64×64 | Favicon fallback |
| `pwa-192x192.png` | 192×192 | Android home screen icon |
| `pwa-512x512.png` | 512×512 | Android splash screen, install prompt |
| `maskable-icon-512x512.png` | 512×512 | Android adaptive icon (with safe zone padding) |
| `apple-touch-icon-180x180.png` | 180×180 | iOS home screen icon |
| `favicon.svg` | scalable | Modern browsers favicon |

### Icon Design

Teal background (#0d9488) with "BL" text or simple coffee cup silhouette in white. These are functional placeholders — the user can replace them with final branding later.

### Maskable Icon

The maskable variant includes extra padding so the icon content stays within the safe zone when Android applies circular, squircle, or other adaptive masks. The safe zone is the inner 80% of the icon (centered).

## Service Worker

### Strategy: Precache App Shell

The service worker (generated by Workbox via `vite-plugin-pwa`) precaches all static assets from the Vite build — HTML, JS, CSS, and static images. This means after the first visit, the app shell loads instantly from cache.

### Runtime Caching Rules

| Pattern | Strategy | Rationale |
|---------|----------|-----------|
| App shell (HTML, JS, CSS) | Precache | Generated at build time by Workbox |
| Google Fonts stylesheets (`fonts.googleapis.com`) | StaleWhileRevalidate | CSS may update with new font subsets |
| Google Fonts files (`fonts.gstatic.com`) | CacheFirst (1 year) | Font files are immutable, safe to cache indefinitely |
| API calls (`/api/*`) | **No caching** | JWT-authenticated; stale data causes confusion |

### What the Service Worker Does NOT Do

- No offline data fallback — API calls fail normally when offline
- No background sync — mutations are not queued
- No push notifications
- No offline page — the cached app shell renders, but API-dependent pages show errors

## Update Strategy

**`registerType: autoUpdate`** — the simplest approach:

1. Browser checks for SW updates on navigation (or every 60 minutes if intervalPeriodicSync is set)
2. If a new SW is found, it installs in the background
3. On next navigation, the new SW activates and serves updated assets
4. No user prompt, no "Update available" toast

This is appropriate because:
- Single user — no risk of different users seeing different versions
- No offline data to migrate between SW versions
- App is simple enough that seamless updates cause no issues

## Meta Tags

Added to `frontend/index.html` `<head>`:

```html
<!-- PWA -->
<meta name="theme-color" content="#0d9488" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png" />
```

The `theme-color` meta tag controls:
- Android: Status bar color in standalone mode
- Safari: Tab bar tinting

## Cache Headers (Caddy)

Caddy should serve the service worker and manifest with appropriate headers:

| Path | Header | Rationale |
|------|--------|-----------|
| `/sw.js` | `Cache-Control: no-cache` | Browser must always check for SW updates |
| `/manifest.webmanifest` | `Cache-Control: no-cache` | Ensure manifest changes are picked up |
| Hashed assets (`/assets/*`) | `Cache-Control: max-age=31536000, immutable` | Vite-built assets have content hashes |

The `no-cache` directive means "revalidate on every request" (not "don't cache"). The browser still caches the file but checks with the server via If-Modified-Since/ETag before using it. This ensures SW updates are detected promptly.

## Design Decisions

### vite-plugin-pwa over Manual Setup

**Chose vite-plugin-pwa because:**
- Auto-generates manifest from Vite config
- Auto-generates Workbox service worker with precache manifest
- Handles dev/build mode differences
- Widely adopted in the Vite ecosystem
- Type-safe configuration

**Trade-off:** Adds a build dependency. Acceptable given it's dev-only.

### No API Caching

**Chose to skip API caching because:**
- API calls use JWT auth — cached responses may have stale tokens
- The app is for active use (brewing coffee), not passive reading
- Stale experiment data could lead to duplicate entries or overwritten results
- Offline mode would require IndexedDB + sync logic — disproportionate complexity for the benefit

### No Custom Install Prompt

**Chose to skip because:**
- Browser's native install prompt is sufficient
- Single user — no need to maximize install conversion
- Less code to maintain

### autoUpdate over prompt

**Chose autoUpdate because:**
- No "Update available" UI to build
- Single user — no coordination concerns
- App is stateless between page loads (no long-running sessions to interrupt)
